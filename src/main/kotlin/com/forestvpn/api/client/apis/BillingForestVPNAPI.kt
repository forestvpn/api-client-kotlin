/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.forestvpn.api.client.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import com.forestvpn.api.client.models.BillingAccount
import com.forestvpn.api.client.models.BillingFeature
import com.forestvpn.api.client.models.Bundle
import com.forestvpn.api.client.models.CreateStripeSetupIntentRequest
import com.forestvpn.api.client.models.Error
import com.forestvpn.api.client.models.PaymentMethod
import com.forestvpn.api.client.models.PaymentOption
import com.forestvpn.api.client.models.Product
import com.forestvpn.api.client.models.StripeSetupIntent
import com.forestvpn.api.client.models.Subscription
import com.forestvpn.api.client.models.SubscriptionItem

import com.squareup.moshi.Json

import com.forestvpn.api.client.infrastructure.ApiClient
import com.forestvpn.api.client.infrastructure.ApiResponse
import com.forestvpn.api.client.infrastructure.ClientException
import com.forestvpn.api.client.infrastructure.ClientError
import com.forestvpn.api.client.infrastructure.ServerException
import com.forestvpn.api.client.infrastructure.ServerError
import com.forestvpn.api.client.infrastructure.MultiValueMap
import com.forestvpn.api.client.infrastructure.PartConfig
import com.forestvpn.api.client.infrastructure.RequestConfig
import com.forestvpn.api.client.infrastructure.RequestMethod
import com.forestvpn.api.client.infrastructure.ResponseType
import com.forestvpn.api.client.infrastructure.Success
import com.forestvpn.api.client.infrastructure.toMultiValue

class BillingForestVPNAPI(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://api.forestvpn.com/v2")
        }
    }

    /**
     * Cancel subscription
     * 
     * @param subscriptionID 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun cancelSubscription(subscriptionID: java.util.UUID) : Unit {
        val localVarResponse = cancelSubscriptionWithHttpInfo(subscriptionID = subscriptionID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Cancel subscription
     * 
     * @param subscriptionID 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun cancelSubscriptionWithHttpInfo(subscriptionID: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = cancelSubscriptionRequestConfig(subscriptionID = subscriptionID)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation cancelSubscription
     *
     * @param subscriptionID 
     * @return RequestConfig
     */
    fun cancelSubscriptionRequestConfig(subscriptionID: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/billing/subscriptions/{subscriptionID}/".replace("{"+"subscriptionID"+"}", encodeURIComponent(subscriptionID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Create stripe&#39;s setup intent for add new payment method.
     * 
     * @param createStripeSetupIntentRequest  (optional)
     * @return StripeSetupIntent
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createPaymentMethodStripeSetupIntent(createStripeSetupIntentRequest: CreateStripeSetupIntentRequest? = null) : StripeSetupIntent {
        val localVarResponse = createPaymentMethodStripeSetupIntentWithHttpInfo(createStripeSetupIntentRequest = createStripeSetupIntentRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as StripeSetupIntent
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create stripe&#39;s setup intent for add new payment method.
     * 
     * @param createStripeSetupIntentRequest  (optional)
     * @return ApiResponse<StripeSetupIntent?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createPaymentMethodStripeSetupIntentWithHttpInfo(createStripeSetupIntentRequest: CreateStripeSetupIntentRequest?) : ApiResponse<StripeSetupIntent?> {
        val localVariableConfig = createPaymentMethodStripeSetupIntentRequestConfig(createStripeSetupIntentRequest = createStripeSetupIntentRequest)

        return request<CreateStripeSetupIntentRequest, StripeSetupIntent>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createPaymentMethodStripeSetupIntent
     *
     * @param createStripeSetupIntentRequest  (optional)
     * @return RequestConfig
     */
    fun createPaymentMethodStripeSetupIntentRequestConfig(createStripeSetupIntentRequest: CreateStripeSetupIntentRequest?) : RequestConfig<CreateStripeSetupIntentRequest> {
        val localVariableBody = createStripeSetupIntentRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/billing/payment-methods/stripe/setup-intents/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Create subscription
     * 
     * @param subscription  (optional)
     * @return Subscription
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createSubscription(subscription: Subscription? = null) : Subscription {
        val localVarResponse = createSubscriptionWithHttpInfo(subscription = subscription)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Subscription
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create subscription
     * 
     * @param subscription  (optional)
     * @return ApiResponse<Subscription?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createSubscriptionWithHttpInfo(subscription: Subscription?) : ApiResponse<Subscription?> {
        val localVariableConfig = createSubscriptionRequestConfig(subscription = subscription)

        return request<Subscription, Subscription>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createSubscription
     *
     * @param subscription  (optional)
     * @return RequestConfig
     */
    fun createSubscriptionRequestConfig(subscription: Subscription?) : RequestConfig<Subscription> {
        val localVariableBody = subscription
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/billing/subscriptions/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Delete payment method
     * 
     * @param paymentMethodID 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deletePaymentMethod(paymentMethodID: java.util.UUID) : Unit {
        val localVarResponse = deletePaymentMethodWithHttpInfo(paymentMethodID = paymentMethodID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete payment method
     * 
     * @param paymentMethodID 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun deletePaymentMethodWithHttpInfo(paymentMethodID: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = deletePaymentMethodRequestConfig(paymentMethodID = paymentMethodID)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deletePaymentMethod
     *
     * @param paymentMethodID 
     * @return RequestConfig
     */
    fun deletePaymentMethodRequestConfig(paymentMethodID: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/billing/payment-methods/{paymentMethodID}/".replace("{"+"paymentMethodID"+"}", encodeURIComponent(paymentMethodID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Billing account info
     * 
     * @return BillingAccount
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBillingAccount() : BillingAccount {
        val localVarResponse = getBillingAccountWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BillingAccount
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Billing account info
     * 
     * @return ApiResponse<BillingAccount?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBillingAccountWithHttpInfo() : ApiResponse<BillingAccount?> {
        val localVariableConfig = getBillingAccountRequestConfig()

        return request<Unit, BillingAccount>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBillingAccount
     *
     * @return RequestConfig
     */
    fun getBillingAccountRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/billing/account/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Bundle info
     * 
     * @param bundleID 
     * @return Bundle
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBillingBundle(bundleID: kotlin.String) : Bundle {
        val localVarResponse = getBillingBundleWithHttpInfo(bundleID = bundleID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Bundle
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Bundle info
     * 
     * @param bundleID 
     * @return ApiResponse<Bundle?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBillingBundleWithHttpInfo(bundleID: kotlin.String) : ApiResponse<Bundle?> {
        val localVariableConfig = getBillingBundleRequestConfig(bundleID = bundleID)

        return request<Unit, Bundle>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBillingBundle
     *
     * @param bundleID 
     * @return RequestConfig
     */
    fun getBillingBundleRequestConfig(bundleID: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/billing/bundles/{bundleID}/".replace("{"+"bundleID"+"}", encodeURIComponent(bundleID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Payment option info
     * 
     * @param paymentOptionID 
     * @return PaymentOption
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBillingPaymentOption(paymentOptionID: kotlin.String) : PaymentOption {
        val localVarResponse = getBillingPaymentOptionWithHttpInfo(paymentOptionID = paymentOptionID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaymentOption
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Payment option info
     * 
     * @param paymentOptionID 
     * @return ApiResponse<PaymentOption?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBillingPaymentOptionWithHttpInfo(paymentOptionID: kotlin.String) : ApiResponse<PaymentOption?> {
        val localVariableConfig = getBillingPaymentOptionRequestConfig(paymentOptionID = paymentOptionID)

        return request<Unit, PaymentOption>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBillingPaymentOption
     *
     * @param paymentOptionID 
     * @return RequestConfig
     */
    fun getBillingPaymentOptionRequestConfig(paymentOptionID: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/billing/payment-options/{paymentOptionID}/".replace("{"+"paymentOptionID"+"}", encodeURIComponent(paymentOptionID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Product info
     * 
     * @param productID 
     * @return Product
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBillingProduct(productID: kotlin.String) : Product {
        val localVarResponse = getBillingProductWithHttpInfo(productID = productID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Product
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Product info
     * 
     * @param productID 
     * @return ApiResponse<Product?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBillingProductWithHttpInfo(productID: kotlin.String) : ApiResponse<Product?> {
        val localVariableConfig = getBillingProductRequestConfig(productID = productID)

        return request<Unit, Product>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBillingProduct
     *
     * @param productID 
     * @return RequestConfig
     */
    fun getBillingProductRequestConfig(productID: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/billing/products/{productID}/".replace("{"+"productID"+"}", encodeURIComponent(productID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Payment method info
     * 
     * @param paymentMethodID 
     * @return PaymentMethod
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPaymentMethod(paymentMethodID: java.util.UUID) : PaymentMethod {
        val localVarResponse = getPaymentMethodWithHttpInfo(paymentMethodID = paymentMethodID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaymentMethod
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Payment method info
     * 
     * @param paymentMethodID 
     * @return ApiResponse<PaymentMethod?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPaymentMethodWithHttpInfo(paymentMethodID: java.util.UUID) : ApiResponse<PaymentMethod?> {
        val localVariableConfig = getPaymentMethodRequestConfig(paymentMethodID = paymentMethodID)

        return request<Unit, PaymentMethod>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPaymentMethod
     *
     * @param paymentMethodID 
     * @return RequestConfig
     */
    fun getPaymentMethodRequestConfig(paymentMethodID: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/billing/payment-methods/{paymentMethodID}/".replace("{"+"paymentMethodID"+"}", encodeURIComponent(paymentMethodID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Subscription info
     * 
     * @param subscriptionID 
     * @return Subscription
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getSubscription(subscriptionID: java.util.UUID) : Subscription {
        val localVarResponse = getSubscriptionWithHttpInfo(subscriptionID = subscriptionID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Subscription
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Subscription info
     * 
     * @param subscriptionID 
     * @return ApiResponse<Subscription?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getSubscriptionWithHttpInfo(subscriptionID: java.util.UUID) : ApiResponse<Subscription?> {
        val localVariableConfig = getSubscriptionRequestConfig(subscriptionID = subscriptionID)

        return request<Unit, Subscription>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getSubscription
     *
     * @param subscriptionID 
     * @return RequestConfig
     */
    fun getSubscriptionRequestConfig(subscriptionID: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/billing/subscriptions/{subscriptionID}/".replace("{"+"subscriptionID"+"}", encodeURIComponent(subscriptionID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Subscription item info
     * 
     * @param subscriptionItemID 
     * @return SubscriptionItem
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getSubscriptionItem(subscriptionItemID: java.util.UUID) : SubscriptionItem {
        val localVarResponse = getSubscriptionItemWithHttpInfo(subscriptionItemID = subscriptionItemID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SubscriptionItem
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Subscription item info
     * 
     * @param subscriptionItemID 
     * @return ApiResponse<SubscriptionItem?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getSubscriptionItemWithHttpInfo(subscriptionItemID: java.util.UUID) : ApiResponse<SubscriptionItem?> {
        val localVariableConfig = getSubscriptionItemRequestConfig(subscriptionItemID = subscriptionItemID)

        return request<Unit, SubscriptionItem>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getSubscriptionItem
     *
     * @param subscriptionItemID 
     * @return RequestConfig
     */
    fun getSubscriptionItemRequestConfig(subscriptionItemID: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/billing/subscription-items/{subscriptionItemID}/".replace("{"+"subscriptionItemID"+"}", encodeURIComponent(subscriptionItemID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Billing bundles list
     * 
     * @return kotlin.collections.List<Bundle>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listBillingBundles() : kotlin.collections.List<Bundle> {
        val localVarResponse = listBillingBundlesWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Bundle>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Billing bundles list
     * 
     * @return ApiResponse<kotlin.collections.List<Bundle>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listBillingBundlesWithHttpInfo() : ApiResponse<kotlin.collections.List<Bundle>?> {
        val localVariableConfig = listBillingBundlesRequestConfig()

        return request<Unit, kotlin.collections.List<Bundle>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listBillingBundles
     *
     * @return RequestConfig
     */
    fun listBillingBundlesRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/billing/bundles/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Billing feature list
     * 
     * @return kotlin.collections.List<BillingFeature>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listBillingFeatures() : kotlin.collections.List<BillingFeature> {
        val localVarResponse = listBillingFeaturesWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<BillingFeature>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Billing feature list
     * 
     * @return ApiResponse<kotlin.collections.List<BillingFeature>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listBillingFeaturesWithHttpInfo() : ApiResponse<kotlin.collections.List<BillingFeature>?> {
        val localVariableConfig = listBillingFeaturesRequestConfig()

        return request<Unit, kotlin.collections.List<BillingFeature>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listBillingFeatures
     *
     * @return RequestConfig
     */
    fun listBillingFeaturesRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/billing/features/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Billing payment option list
     * 
     * @return kotlin.collections.List<PaymentOption>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listBillingPaymentOptions() : kotlin.collections.List<PaymentOption> {
        val localVarResponse = listBillingPaymentOptionsWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<PaymentOption>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Billing payment option list
     * 
     * @return ApiResponse<kotlin.collections.List<PaymentOption>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listBillingPaymentOptionsWithHttpInfo() : ApiResponse<kotlin.collections.List<PaymentOption>?> {
        val localVariableConfig = listBillingPaymentOptionsRequestConfig()

        return request<Unit, kotlin.collections.List<PaymentOption>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listBillingPaymentOptions
     *
     * @return RequestConfig
     */
    fun listBillingPaymentOptionsRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/billing/payment-options/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Billing products list
     * 
     * @return kotlin.collections.List<Product>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listBillingProducts() : kotlin.collections.List<Product> {
        val localVarResponse = listBillingProductsWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Product>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Billing products list
     * 
     * @return ApiResponse<kotlin.collections.List<Product>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listBillingProductsWithHttpInfo() : ApiResponse<kotlin.collections.List<Product>?> {
        val localVariableConfig = listBillingProductsRequestConfig()

        return request<Unit, kotlin.collections.List<Product>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listBillingProducts
     *
     * @return RequestConfig
     */
    fun listBillingProductsRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/billing/products/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Payment method list
     * 
     * @return kotlin.collections.List<PaymentMethod>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listPaymentMethods() : kotlin.collections.List<PaymentMethod> {
        val localVarResponse = listPaymentMethodsWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<PaymentMethod>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Payment method list
     * 
     * @return ApiResponse<kotlin.collections.List<PaymentMethod>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listPaymentMethodsWithHttpInfo() : ApiResponse<kotlin.collections.List<PaymentMethod>?> {
        val localVariableConfig = listPaymentMethodsRequestConfig()

        return request<Unit, kotlin.collections.List<PaymentMethod>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listPaymentMethods
     *
     * @return RequestConfig
     */
    fun listPaymentMethodsRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/billing/payment-methods/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Subscription items list
     * 
     * @param subscription  (optional)
     * @param perPage  (optional)
     * @param page  (optional)
     * @return kotlin.collections.List<SubscriptionItem>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listSubscriptionItems(subscription: kotlin.String? = null, perPage: kotlin.Int? = null, page: kotlin.Int? = null) : kotlin.collections.List<SubscriptionItem> {
        val localVarResponse = listSubscriptionItemsWithHttpInfo(subscription = subscription, perPage = perPage, page = page)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<SubscriptionItem>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Subscription items list
     * 
     * @param subscription  (optional)
     * @param perPage  (optional)
     * @param page  (optional)
     * @return ApiResponse<kotlin.collections.List<SubscriptionItem>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listSubscriptionItemsWithHttpInfo(subscription: kotlin.String?, perPage: kotlin.Int?, page: kotlin.Int?) : ApiResponse<kotlin.collections.List<SubscriptionItem>?> {
        val localVariableConfig = listSubscriptionItemsRequestConfig(subscription = subscription, perPage = perPage, page = page)

        return request<Unit, kotlin.collections.List<SubscriptionItem>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listSubscriptionItems
     *
     * @param subscription  (optional)
     * @param perPage  (optional)
     * @param page  (optional)
     * @return RequestConfig
     */
    fun listSubscriptionItemsRequestConfig(subscription: kotlin.String?, perPage: kotlin.Int?, page: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (subscription != null) {
                    put("subscription", listOf(subscription.toString()))
                }
                if (perPage != null) {
                    put("per_page", listOf(perPage.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/billing/subscription-items/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Billing subscriptions list
     * 
     * @param product  (optional)
     * @param perPage  (optional)
     * @param page  (optional)
     * @return kotlin.collections.List<Subscription>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listSubscriptions(product: kotlin.String? = null, perPage: kotlin.Int? = null, page: kotlin.Int? = null) : kotlin.collections.List<Subscription> {
        val localVarResponse = listSubscriptionsWithHttpInfo(product = product, perPage = perPage, page = page)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Subscription>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Billing subscriptions list
     * 
     * @param product  (optional)
     * @param perPage  (optional)
     * @param page  (optional)
     * @return ApiResponse<kotlin.collections.List<Subscription>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listSubscriptionsWithHttpInfo(product: kotlin.String?, perPage: kotlin.Int?, page: kotlin.Int?) : ApiResponse<kotlin.collections.List<Subscription>?> {
        val localVariableConfig = listSubscriptionsRequestConfig(product = product, perPage = perPage, page = page)

        return request<Unit, kotlin.collections.List<Subscription>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listSubscriptions
     *
     * @param product  (optional)
     * @param perPage  (optional)
     * @param page  (optional)
     * @return RequestConfig
     */
    fun listSubscriptionsRequestConfig(product: kotlin.String?, perPage: kotlin.Int?, page: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (product != null) {
                    put("product", listOf(product.toString()))
                }
                if (perPage != null) {
                    put("per_page", listOf(perPage.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/billing/subscriptions/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Reactivate subscription
     * 
     * @param subscriptionID 
     * @return Subscription
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun reactivateSubscription(subscriptionID: java.util.UUID) : Subscription {
        val localVarResponse = reactivateSubscriptionWithHttpInfo(subscriptionID = subscriptionID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Subscription
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Reactivate subscription
     * 
     * @param subscriptionID 
     * @return ApiResponse<Subscription?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun reactivateSubscriptionWithHttpInfo(subscriptionID: java.util.UUID) : ApiResponse<Subscription?> {
        val localVariableConfig = reactivateSubscriptionRequestConfig(subscriptionID = subscriptionID)

        return request<Unit, Subscription>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation reactivateSubscription
     *
     * @param subscriptionID 
     * @return RequestConfig
     */
    fun reactivateSubscriptionRequestConfig(subscriptionID: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/billing/subscriptions/{subscriptionID}/reactivate/".replace("{"+"subscriptionID"+"}", encodeURIComponent(subscriptionID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Update billing account
     * 
     * @param billingAccount 
     * @return BillingAccount
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateBillingAccount(billingAccount: BillingAccount) : BillingAccount {
        val localVarResponse = updateBillingAccountWithHttpInfo(billingAccount = billingAccount)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BillingAccount
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update billing account
     * 
     * @param billingAccount 
     * @return ApiResponse<BillingAccount?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateBillingAccountWithHttpInfo(billingAccount: BillingAccount) : ApiResponse<BillingAccount?> {
        val localVariableConfig = updateBillingAccountRequestConfig(billingAccount = billingAccount)

        return request<BillingAccount, BillingAccount>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateBillingAccount
     *
     * @param billingAccount 
     * @return RequestConfig
     */
    fun updateBillingAccountRequestConfig(billingAccount: BillingAccount) : RequestConfig<BillingAccount> {
        val localVariableBody = billingAccount
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/billing/account/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Update subscription item
     * 
     * @param subscriptionItemID 
     * @param subscriptionItem 
     * @return SubscriptionItem
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateSubscriptionItem(subscriptionItemID: java.util.UUID, subscriptionItem: SubscriptionItem) : SubscriptionItem {
        val localVarResponse = updateSubscriptionItemWithHttpInfo(subscriptionItemID = subscriptionItemID, subscriptionItem = subscriptionItem)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SubscriptionItem
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update subscription item
     * 
     * @param subscriptionItemID 
     * @param subscriptionItem 
     * @return ApiResponse<SubscriptionItem?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateSubscriptionItemWithHttpInfo(subscriptionItemID: java.util.UUID, subscriptionItem: SubscriptionItem) : ApiResponse<SubscriptionItem?> {
        val localVariableConfig = updateSubscriptionItemRequestConfig(subscriptionItemID = subscriptionItemID, subscriptionItem = subscriptionItem)

        return request<SubscriptionItem, SubscriptionItem>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateSubscriptionItem
     *
     * @param subscriptionItemID 
     * @param subscriptionItem 
     * @return RequestConfig
     */
    fun updateSubscriptionItemRequestConfig(subscriptionItemID: java.util.UUID, subscriptionItem: SubscriptionItem) : RequestConfig<SubscriptionItem> {
        val localVariableBody = subscriptionItem
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/billing/subscription-items/{subscriptionItemID}/".replace("{"+"subscriptionItemID"+"}", encodeURIComponent(subscriptionItemID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
