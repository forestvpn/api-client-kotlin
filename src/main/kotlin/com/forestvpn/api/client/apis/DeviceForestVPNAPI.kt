/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.forestvpn.api.client.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import com.forestvpn.api.client.models.ConnectionMode
import com.forestvpn.api.client.models.CreateOrUpdateDeviceRequest
import com.forestvpn.api.client.models.CreateOrUpdatePortForwardingRequest
import com.forestvpn.api.client.models.Device
import com.forestvpn.api.client.models.DeviceStats
import com.forestvpn.api.client.models.Error
import com.forestvpn.api.client.models.PortForwarding
import com.forestvpn.api.client.models.WireGuard
import com.forestvpn.api.client.models.WireGuardPeer

import com.squareup.moshi.Json

import com.forestvpn.api.client.infrastructure.ApiClient
import com.forestvpn.api.client.infrastructure.ApiResponse
import com.forestvpn.api.client.infrastructure.ClientException
import com.forestvpn.api.client.infrastructure.ClientError
import com.forestvpn.api.client.infrastructure.ServerException
import com.forestvpn.api.client.infrastructure.ServerError
import com.forestvpn.api.client.infrastructure.MultiValueMap
import com.forestvpn.api.client.infrastructure.PartConfig
import com.forestvpn.api.client.infrastructure.RequestConfig
import com.forestvpn.api.client.infrastructure.RequestMethod
import com.forestvpn.api.client.infrastructure.ResponseType
import com.forestvpn.api.client.infrastructure.Success
import com.forestvpn.api.client.infrastructure.toMultiValue

class DeviceForestVPNAPI(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://api.forestvpn.com/v2")
        }
    }

    /**
     * Create new device
     * Create new device 
     * @param createOrUpdateDeviceRequest  (optional)
     * @return Device
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createDevice(createOrUpdateDeviceRequest: CreateOrUpdateDeviceRequest? = null) : Device {
        val localVarResponse = createDeviceWithHttpInfo(createOrUpdateDeviceRequest = createOrUpdateDeviceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Device
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create new device
     * Create new device 
     * @param createOrUpdateDeviceRequest  (optional)
     * @return ApiResponse<Device?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createDeviceWithHttpInfo(createOrUpdateDeviceRequest: CreateOrUpdateDeviceRequest?) : ApiResponse<Device?> {
        val localVariableConfig = createDeviceRequestConfig(createOrUpdateDeviceRequest = createOrUpdateDeviceRequest)

        return request<CreateOrUpdateDeviceRequest, Device>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createDevice
     *
     * @param createOrUpdateDeviceRequest  (optional)
     * @return RequestConfig
     */
    fun createDeviceRequestConfig(createOrUpdateDeviceRequest: CreateOrUpdateDeviceRequest?) : RequestConfig<CreateOrUpdateDeviceRequest> {
        val localVariableBody = createOrUpdateDeviceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/devices/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Create new device port forwarding
     * Create new device port forwarding 
     * @param deviceID 
     * @param createOrUpdatePortForwardingRequest  (optional)
     * @return PortForwarding
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createDevicePortForwarding(deviceID: java.util.UUID, createOrUpdatePortForwardingRequest: CreateOrUpdatePortForwardingRequest? = null) : PortForwarding {
        val localVarResponse = createDevicePortForwardingWithHttpInfo(deviceID = deviceID, createOrUpdatePortForwardingRequest = createOrUpdatePortForwardingRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PortForwarding
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create new device port forwarding
     * Create new device port forwarding 
     * @param deviceID 
     * @param createOrUpdatePortForwardingRequest  (optional)
     * @return ApiResponse<PortForwarding?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createDevicePortForwardingWithHttpInfo(deviceID: java.util.UUID, createOrUpdatePortForwardingRequest: CreateOrUpdatePortForwardingRequest?) : ApiResponse<PortForwarding?> {
        val localVariableConfig = createDevicePortForwardingRequestConfig(deviceID = deviceID, createOrUpdatePortForwardingRequest = createOrUpdatePortForwardingRequest)

        return request<CreateOrUpdatePortForwardingRequest, PortForwarding>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createDevicePortForwarding
     *
     * @param deviceID 
     * @param createOrUpdatePortForwardingRequest  (optional)
     * @return RequestConfig
     */
    fun createDevicePortForwardingRequestConfig(deviceID: java.util.UUID, createOrUpdatePortForwardingRequest: CreateOrUpdatePortForwardingRequest?) : RequestConfig<CreateOrUpdatePortForwardingRequest> {
        val localVariableBody = createOrUpdatePortForwardingRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/devices/{deviceID}/port-forwarding/".replace("{"+"deviceID"+"}", encodeURIComponent(deviceID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Delete Device
     * Delete device by id 
     * @param deviceID 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteDevice(deviceID: java.util.UUID) : Unit {
        val localVarResponse = deleteDeviceWithHttpInfo(deviceID = deviceID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete Device
     * Delete device by id 
     * @param deviceID 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteDeviceWithHttpInfo(deviceID: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = deleteDeviceRequestConfig(deviceID = deviceID)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteDevice
     *
     * @param deviceID 
     * @return RequestConfig
     */
    fun deleteDeviceRequestConfig(deviceID: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/devices/{deviceID}/".replace("{"+"deviceID"+"}", encodeURIComponent(deviceID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Delete Device&#39;s Port Forwarding
     * Delete device&#39;s port forwarding by id 
     * @param deviceID 
     * @param portForwardingID 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteDevicePortForwarding(deviceID: java.util.UUID, portForwardingID: java.util.UUID) : Unit {
        val localVarResponse = deleteDevicePortForwardingWithHttpInfo(deviceID = deviceID, portForwardingID = portForwardingID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete Device&#39;s Port Forwarding
     * Delete device&#39;s port forwarding by id 
     * @param deviceID 
     * @param portForwardingID 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteDevicePortForwardingWithHttpInfo(deviceID: java.util.UUID, portForwardingID: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = deleteDevicePortForwardingRequestConfig(deviceID = deviceID, portForwardingID = portForwardingID)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteDevicePortForwarding
     *
     * @param deviceID 
     * @param portForwardingID 
     * @return RequestConfig
     */
    fun deleteDevicePortForwardingRequestConfig(deviceID: java.util.UUID, portForwardingID: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/devices/{deviceID}/port-forwarding/{portForwardingID}/".replace("{"+"deviceID"+"}", encodeURIComponent(deviceID.toString())).replace("{"+"portForwardingID"+"}", encodeURIComponent(portForwardingID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Device Info
     * Retrieve device info 
     * @param deviceID 
     * @return Device
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getDevice(deviceID: java.util.UUID) : Device {
        val localVarResponse = getDeviceWithHttpInfo(deviceID = deviceID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Device
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Device Info
     * Retrieve device info 
     * @param deviceID 
     * @return ApiResponse<Device?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getDeviceWithHttpInfo(deviceID: java.util.UUID) : ApiResponse<Device?> {
        val localVariableConfig = getDeviceRequestConfig(deviceID = deviceID)

        return request<Unit, Device>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getDevice
     *
     * @param deviceID 
     * @return RequestConfig
     */
    fun getDeviceRequestConfig(deviceID: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/devices/{deviceID}/".replace("{"+"deviceID"+"}", encodeURIComponent(deviceID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Device&#39;s stats detail
     * 
     * @param deviceID 
     * @param statsID 
     * @return DeviceStats
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getDeviceStats(deviceID: java.util.UUID, statsID: java.util.UUID) : DeviceStats {
        val localVarResponse = getDeviceStatsWithHttpInfo(deviceID = deviceID, statsID = statsID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DeviceStats
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Device&#39;s stats detail
     * 
     * @param deviceID 
     * @param statsID 
     * @return ApiResponse<DeviceStats?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getDeviceStatsWithHttpInfo(deviceID: java.util.UUID, statsID: java.util.UUID) : ApiResponse<DeviceStats?> {
        val localVariableConfig = getDeviceStatsRequestConfig(deviceID = deviceID, statsID = statsID)

        return request<Unit, DeviceStats>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getDeviceStats
     *
     * @param deviceID 
     * @param statsID 
     * @return RequestConfig
     */
    fun getDeviceStatsRequestConfig(deviceID: java.util.UUID, statsID: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/devices/{deviceID}/stats/{statsID}/".replace("{"+"deviceID"+"}", encodeURIComponent(deviceID.toString())).replace("{"+"statsID"+"}", encodeURIComponent(statsID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Device&#39;s wireguard profile detail
     * 
     * @param deviceID 
     * @param wireGuardID 
     * @return WireGuard
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getDeviceWireGuard(deviceID: java.util.UUID, wireGuardID: java.util.UUID) : WireGuard {
        val localVarResponse = getDeviceWireGuardWithHttpInfo(deviceID = deviceID, wireGuardID = wireGuardID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as WireGuard
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Device&#39;s wireguard profile detail
     * 
     * @param deviceID 
     * @param wireGuardID 
     * @return ApiResponse<WireGuard?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getDeviceWireGuardWithHttpInfo(deviceID: java.util.UUID, wireGuardID: java.util.UUID) : ApiResponse<WireGuard?> {
        val localVariableConfig = getDeviceWireGuardRequestConfig(deviceID = deviceID, wireGuardID = wireGuardID)

        return request<Unit, WireGuard>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getDeviceWireGuard
     *
     * @param deviceID 
     * @param wireGuardID 
     * @return RequestConfig
     */
    fun getDeviceWireGuardRequestConfig(deviceID: java.util.UUID, wireGuardID: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/devices/{deviceID}/wireguards/{wireGuardID}/".replace("{"+"deviceID"+"}", encodeURIComponent(deviceID.toString())).replace("{"+"wireGuardID"+"}", encodeURIComponent(wireGuardID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Device bindings
     * Each device has bindings to specific servers. This methods returns hostnames where this device binded in a particular time. 
     * @param deviceID 
     * @return kotlin.collections.List<kotlin.String>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listDeviceBindings(deviceID: java.util.UUID) : kotlin.collections.List<kotlin.String> {
        val localVarResponse = listDeviceBindingsWithHttpInfo(deviceID = deviceID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<kotlin.String>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Device bindings
     * Each device has bindings to specific servers. This methods returns hostnames where this device binded in a particular time. 
     * @param deviceID 
     * @return ApiResponse<kotlin.collections.List<kotlin.String>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listDeviceBindingsWithHttpInfo(deviceID: java.util.UUID) : ApiResponse<kotlin.collections.List<kotlin.String>?> {
        val localVariableConfig = listDeviceBindingsRequestConfig(deviceID = deviceID)

        return request<Unit, kotlin.collections.List<kotlin.String>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listDeviceBindings
     *
     * @param deviceID 
     * @return RequestConfig
     */
    fun listDeviceBindingsRequestConfig(deviceID: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/devices/{deviceID}/bindings/".replace("{"+"deviceID"+"}", encodeURIComponent(deviceID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Device connection modes
     * This methods returns list of connection modes are availbale for current device. 
     * @param deviceID 
     * @param xAndroidPackage  (optional)
     * @param xAndroidSHA1  (optional)
     * @return kotlin.collections.List<ConnectionMode>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listDeviceConnectionModes(deviceID: java.util.UUID, xAndroidPackage: kotlin.String? = null, xAndroidSHA1: kotlin.String? = null) : kotlin.collections.List<ConnectionMode> {
        val localVarResponse = listDeviceConnectionModesWithHttpInfo(deviceID = deviceID, xAndroidPackage = xAndroidPackage, xAndroidSHA1 = xAndroidSHA1)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<ConnectionMode>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Device connection modes
     * This methods returns list of connection modes are availbale for current device. 
     * @param deviceID 
     * @param xAndroidPackage  (optional)
     * @param xAndroidSHA1  (optional)
     * @return ApiResponse<kotlin.collections.List<ConnectionMode>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listDeviceConnectionModesWithHttpInfo(deviceID: java.util.UUID, xAndroidPackage: kotlin.String?, xAndroidSHA1: kotlin.String?) : ApiResponse<kotlin.collections.List<ConnectionMode>?> {
        val localVariableConfig = listDeviceConnectionModesRequestConfig(deviceID = deviceID, xAndroidPackage = xAndroidPackage, xAndroidSHA1 = xAndroidSHA1)

        return request<Unit, kotlin.collections.List<ConnectionMode>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listDeviceConnectionModes
     *
     * @param deviceID 
     * @param xAndroidPackage  (optional)
     * @param xAndroidSHA1  (optional)
     * @return RequestConfig
     */
    fun listDeviceConnectionModesRequestConfig(deviceID: java.util.UUID, xAndroidPackage: kotlin.String?, xAndroidSHA1: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xAndroidPackage?.apply { localVariableHeaders["X-Android-Package"] = this.toString() }
        xAndroidSHA1?.apply { localVariableHeaders["X-Android-SHA1"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/devices/{deviceID}/connection-modes/".replace("{"+"deviceID"+"}", encodeURIComponent(deviceID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Device&#39;s detail stats list
     * 
     * @param deviceID 
     * @param dateTimeAfter  (optional)
     * @param dateTimeBefore  (optional)
     * @param perPage  (optional)
     * @param page  (optional)
     * @return kotlin.collections.List<DeviceStats>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listDeviceDetailStats(deviceID: java.util.UUID, dateTimeAfter: kotlin.String? = null, dateTimeBefore: kotlin.String? = null, perPage: kotlin.Int? = null, page: kotlin.Int? = null) : kotlin.collections.List<DeviceStats> {
        val localVarResponse = listDeviceDetailStatsWithHttpInfo(deviceID = deviceID, dateTimeAfter = dateTimeAfter, dateTimeBefore = dateTimeBefore, perPage = perPage, page = page)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<DeviceStats>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Device&#39;s detail stats list
     * 
     * @param deviceID 
     * @param dateTimeAfter  (optional)
     * @param dateTimeBefore  (optional)
     * @param perPage  (optional)
     * @param page  (optional)
     * @return ApiResponse<kotlin.collections.List<DeviceStats>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listDeviceDetailStatsWithHttpInfo(deviceID: java.util.UUID, dateTimeAfter: kotlin.String?, dateTimeBefore: kotlin.String?, perPage: kotlin.Int?, page: kotlin.Int?) : ApiResponse<kotlin.collections.List<DeviceStats>?> {
        val localVariableConfig = listDeviceDetailStatsRequestConfig(deviceID = deviceID, dateTimeAfter = dateTimeAfter, dateTimeBefore = dateTimeBefore, perPage = perPage, page = page)

        return request<Unit, kotlin.collections.List<DeviceStats>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listDeviceDetailStats
     *
     * @param deviceID 
     * @param dateTimeAfter  (optional)
     * @param dateTimeBefore  (optional)
     * @param perPage  (optional)
     * @param page  (optional)
     * @return RequestConfig
     */
    fun listDeviceDetailStatsRequestConfig(deviceID: java.util.UUID, dateTimeAfter: kotlin.String?, dateTimeBefore: kotlin.String?, perPage: kotlin.Int?, page: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (dateTimeAfter != null) {
                    put("date_time_after", listOf(dateTimeAfter.toString()))
                }
                if (dateTimeBefore != null) {
                    put("date_time_before", listOf(dateTimeBefore.toString()))
                }
                if (perPage != null) {
                    put("per_page", listOf(perPage.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/devices/{deviceID}/detail-stats/".replace("{"+"deviceID"+"}", encodeURIComponent(deviceID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Device Port Forwarding List
     * Retrieve device&#39;s port forwarding lis 
     * @param deviceID 
     * @param perPage  (optional)
     * @param page  (optional)
     * @return kotlin.collections.List<PortForwarding>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listDevicePortForwardings(deviceID: java.util.UUID, perPage: kotlin.Int? = null, page: kotlin.Int? = null) : kotlin.collections.List<PortForwarding> {
        val localVarResponse = listDevicePortForwardingsWithHttpInfo(deviceID = deviceID, perPage = perPage, page = page)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<PortForwarding>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Device Port Forwarding List
     * Retrieve device&#39;s port forwarding lis 
     * @param deviceID 
     * @param perPage  (optional)
     * @param page  (optional)
     * @return ApiResponse<kotlin.collections.List<PortForwarding>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listDevicePortForwardingsWithHttpInfo(deviceID: java.util.UUID, perPage: kotlin.Int?, page: kotlin.Int?) : ApiResponse<kotlin.collections.List<PortForwarding>?> {
        val localVariableConfig = listDevicePortForwardingsRequestConfig(deviceID = deviceID, perPage = perPage, page = page)

        return request<Unit, kotlin.collections.List<PortForwarding>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listDevicePortForwardings
     *
     * @param deviceID 
     * @param perPage  (optional)
     * @param page  (optional)
     * @return RequestConfig
     */
    fun listDevicePortForwardingsRequestConfig(deviceID: java.util.UUID, perPage: kotlin.Int?, page: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (perPage != null) {
                    put("per_page", listOf(perPage.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/devices/{deviceID}/port-forwarding/".replace("{"+"deviceID"+"}", encodeURIComponent(deviceID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Device&#39;s stats list
     * 
     * @param deviceID 
     * @param dateAfter  (optional)
     * @param dateBefore  (optional)
     * @param perPage  (optional)
     * @param page  (optional)
     * @return kotlin.collections.List<DeviceStats>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listDeviceStats(deviceID: java.util.UUID, dateAfter: java.time.LocalDate? = null, dateBefore: java.time.LocalDate? = null, perPage: kotlin.Int? = null, page: kotlin.Int? = null) : kotlin.collections.List<DeviceStats> {
        val localVarResponse = listDeviceStatsWithHttpInfo(deviceID = deviceID, dateAfter = dateAfter, dateBefore = dateBefore, perPage = perPage, page = page)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<DeviceStats>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Device&#39;s stats list
     * 
     * @param deviceID 
     * @param dateAfter  (optional)
     * @param dateBefore  (optional)
     * @param perPage  (optional)
     * @param page  (optional)
     * @return ApiResponse<kotlin.collections.List<DeviceStats>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listDeviceStatsWithHttpInfo(deviceID: java.util.UUID, dateAfter: java.time.LocalDate?, dateBefore: java.time.LocalDate?, perPage: kotlin.Int?, page: kotlin.Int?) : ApiResponse<kotlin.collections.List<DeviceStats>?> {
        val localVariableConfig = listDeviceStatsRequestConfig(deviceID = deviceID, dateAfter = dateAfter, dateBefore = dateBefore, perPage = perPage, page = page)

        return request<Unit, kotlin.collections.List<DeviceStats>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listDeviceStats
     *
     * @param deviceID 
     * @param dateAfter  (optional)
     * @param dateBefore  (optional)
     * @param perPage  (optional)
     * @param page  (optional)
     * @return RequestConfig
     */
    fun listDeviceStatsRequestConfig(deviceID: java.util.UUID, dateAfter: java.time.LocalDate?, dateBefore: java.time.LocalDate?, perPage: kotlin.Int?, page: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (dateAfter != null) {
                    put("date_after", listOf(parseDateToQueryString(dateAfter)))
                }
                if (dateBefore != null) {
                    put("date_before", listOf(parseDateToQueryString(dateBefore)))
                }
                if (perPage != null) {
                    put("per_page", listOf(perPage.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/devices/{deviceID}/stats/".replace("{"+"deviceID"+"}", encodeURIComponent(deviceID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Device&#39;s wireguard peers
     * 
     * @param deviceID 
     * @param wireGuardID 
     * @return kotlin.collections.List<WireGuardPeer>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listDeviceWireGuardPeers(deviceID: java.util.UUID, wireGuardID: java.util.UUID) : kotlin.collections.List<WireGuardPeer> {
        val localVarResponse = listDeviceWireGuardPeersWithHttpInfo(deviceID = deviceID, wireGuardID = wireGuardID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<WireGuardPeer>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Device&#39;s wireguard peers
     * 
     * @param deviceID 
     * @param wireGuardID 
     * @return ApiResponse<kotlin.collections.List<WireGuardPeer>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listDeviceWireGuardPeersWithHttpInfo(deviceID: java.util.UUID, wireGuardID: java.util.UUID) : ApiResponse<kotlin.collections.List<WireGuardPeer>?> {
        val localVariableConfig = listDeviceWireGuardPeersRequestConfig(deviceID = deviceID, wireGuardID = wireGuardID)

        return request<Unit, kotlin.collections.List<WireGuardPeer>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listDeviceWireGuardPeers
     *
     * @param deviceID 
     * @param wireGuardID 
     * @return RequestConfig
     */
    fun listDeviceWireGuardPeersRequestConfig(deviceID: java.util.UUID, wireGuardID: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/devices/{deviceID}/wireguards/{wireGuardID}/peers/".replace("{"+"deviceID"+"}", encodeURIComponent(deviceID.toString())).replace("{"+"wireGuardID"+"}", encodeURIComponent(wireGuardID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Device&#39;s wireguard profiles list
     * 
     * @param deviceID 
     * @param perPage  (optional)
     * @param page  (optional)
     * @return kotlin.collections.List<WireGuard>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listDeviceWireGuards(deviceID: java.util.UUID, perPage: kotlin.Int? = null, page: kotlin.Int? = null) : kotlin.collections.List<WireGuard> {
        val localVarResponse = listDeviceWireGuardsWithHttpInfo(deviceID = deviceID, perPage = perPage, page = page)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<WireGuard>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Device&#39;s wireguard profiles list
     * 
     * @param deviceID 
     * @param perPage  (optional)
     * @param page  (optional)
     * @return ApiResponse<kotlin.collections.List<WireGuard>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listDeviceWireGuardsWithHttpInfo(deviceID: java.util.UUID, perPage: kotlin.Int?, page: kotlin.Int?) : ApiResponse<kotlin.collections.List<WireGuard>?> {
        val localVariableConfig = listDeviceWireGuardsRequestConfig(deviceID = deviceID, perPage = perPage, page = page)

        return request<Unit, kotlin.collections.List<WireGuard>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listDeviceWireGuards
     *
     * @param deviceID 
     * @param perPage  (optional)
     * @param page  (optional)
     * @return RequestConfig
     */
    fun listDeviceWireGuardsRequestConfig(deviceID: java.util.UUID, perPage: kotlin.Int?, page: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (perPage != null) {
                    put("per_page", listOf(perPage.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/devices/{deviceID}/wireguards/".replace("{"+"deviceID"+"}", encodeURIComponent(deviceID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter sort
     */
     enum class Sort_listDevices(val value: kotlin.String) {
         @Json(name = "last_active_at") lastActiveAt("last_active_at"),
         @Json(name = "-last_active_at") minusLastActiveAt("-last_active_at"),
         @Json(name = "created_at") createdAt("created_at"),
         @Json(name = "-created_at") minusCreatedAt("-created_at"),
         @Json(name = "updated_at") updatedAt("updated_at"),
         @Json(name = "-updated_at") minusUpdatedAt("-updated_at")
     }

    /**
     * Device List
     * Retrieve devices list 
     * @param q Filter by search query (optional)
     * @param externalKey Filter by external_key (optional)
     * @param recentlyActive Filter by recently active (optional)
     * @param lastActiveAtAfter Filter by last active at date-time after provided value (optional)
     * @param lastActiveAtBefore Filter by last active at date-time before provided value (optional)
     * @param sort Sort by provided field (optional)
     * @param perPage  (optional)
     * @param page  (optional)
     * @return kotlin.collections.List<Device>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listDevices(q: kotlin.String? = null, externalKey: kotlin.String? = null, recentlyActive: kotlin.Boolean? = null, lastActiveAtAfter: java.time.OffsetDateTime? = null, lastActiveAtBefore: java.time.OffsetDateTime? = null, sort: Sort_listDevices? = null, perPage: kotlin.Int? = null, page: kotlin.Int? = null) : kotlin.collections.List<Device> {
        val localVarResponse = listDevicesWithHttpInfo(q = q, externalKey = externalKey, recentlyActive = recentlyActive, lastActiveAtAfter = lastActiveAtAfter, lastActiveAtBefore = lastActiveAtBefore, sort = sort, perPage = perPage, page = page)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Device>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Device List
     * Retrieve devices list 
     * @param q Filter by search query (optional)
     * @param externalKey Filter by external_key (optional)
     * @param recentlyActive Filter by recently active (optional)
     * @param lastActiveAtAfter Filter by last active at date-time after provided value (optional)
     * @param lastActiveAtBefore Filter by last active at date-time before provided value (optional)
     * @param sort Sort by provided field (optional)
     * @param perPage  (optional)
     * @param page  (optional)
     * @return ApiResponse<kotlin.collections.List<Device>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listDevicesWithHttpInfo(q: kotlin.String?, externalKey: kotlin.String?, recentlyActive: kotlin.Boolean?, lastActiveAtAfter: java.time.OffsetDateTime?, lastActiveAtBefore: java.time.OffsetDateTime?, sort: Sort_listDevices?, perPage: kotlin.Int?, page: kotlin.Int?) : ApiResponse<kotlin.collections.List<Device>?> {
        val localVariableConfig = listDevicesRequestConfig(q = q, externalKey = externalKey, recentlyActive = recentlyActive, lastActiveAtAfter = lastActiveAtAfter, lastActiveAtBefore = lastActiveAtBefore, sort = sort, perPage = perPage, page = page)

        return request<Unit, kotlin.collections.List<Device>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listDevices
     *
     * @param q Filter by search query (optional)
     * @param externalKey Filter by external_key (optional)
     * @param recentlyActive Filter by recently active (optional)
     * @param lastActiveAtAfter Filter by last active at date-time after provided value (optional)
     * @param lastActiveAtBefore Filter by last active at date-time before provided value (optional)
     * @param sort Sort by provided field (optional)
     * @param perPage  (optional)
     * @param page  (optional)
     * @return RequestConfig
     */
    fun listDevicesRequestConfig(q: kotlin.String?, externalKey: kotlin.String?, recentlyActive: kotlin.Boolean?, lastActiveAtAfter: java.time.OffsetDateTime?, lastActiveAtBefore: java.time.OffsetDateTime?, sort: Sort_listDevices?, perPage: kotlin.Int?, page: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (q != null) {
                    put("q", listOf(q.toString()))
                }
                if (externalKey != null) {
                    put("external_key", listOf(externalKey.toString()))
                }
                if (recentlyActive != null) {
                    put("recently_active", listOf(recentlyActive.toString()))
                }
                if (lastActiveAtAfter != null) {
                    put("last_active_at_after", listOf(parseDateToQueryString(lastActiveAtAfter)))
                }
                if (lastActiveAtBefore != null) {
                    put("last_active_at_before", listOf(parseDateToQueryString(lastActiveAtBefore)))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
                if (perPage != null) {
                    put("per_page", listOf(perPage.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/devices/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Update device properties
     * Update device properties 
     * @param deviceID 
     * @param createOrUpdateDeviceRequest 
     * @return Device
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateDevice(deviceID: java.util.UUID, createOrUpdateDeviceRequest: CreateOrUpdateDeviceRequest) : Device {
        val localVarResponse = updateDeviceWithHttpInfo(deviceID = deviceID, createOrUpdateDeviceRequest = createOrUpdateDeviceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Device
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update device properties
     * Update device properties 
     * @param deviceID 
     * @param createOrUpdateDeviceRequest 
     * @return ApiResponse<Device?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateDeviceWithHttpInfo(deviceID: java.util.UUID, createOrUpdateDeviceRequest: CreateOrUpdateDeviceRequest) : ApiResponse<Device?> {
        val localVariableConfig = updateDeviceRequestConfig(deviceID = deviceID, createOrUpdateDeviceRequest = createOrUpdateDeviceRequest)

        return request<CreateOrUpdateDeviceRequest, Device>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateDevice
     *
     * @param deviceID 
     * @param createOrUpdateDeviceRequest 
     * @return RequestConfig
     */
    fun updateDeviceRequestConfig(deviceID: java.util.UUID, createOrUpdateDeviceRequest: CreateOrUpdateDeviceRequest) : RequestConfig<CreateOrUpdateDeviceRequest> {
        val localVariableBody = createOrUpdateDeviceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/devices/{deviceID}/".replace("{"+"deviceID"+"}", encodeURIComponent(deviceID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Update device&#39;s port forwarding
     * Update device&#39;s port forwarding dst_port 
     * @param deviceID 
     * @param portForwardingID 
     * @param createOrUpdatePortForwardingRequest 
     * @return PortForwarding
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateDevicePortForwarding(deviceID: java.util.UUID, portForwardingID: java.util.UUID, createOrUpdatePortForwardingRequest: CreateOrUpdatePortForwardingRequest) : PortForwarding {
        val localVarResponse = updateDevicePortForwardingWithHttpInfo(deviceID = deviceID, portForwardingID = portForwardingID, createOrUpdatePortForwardingRequest = createOrUpdatePortForwardingRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PortForwarding
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update device&#39;s port forwarding
     * Update device&#39;s port forwarding dst_port 
     * @param deviceID 
     * @param portForwardingID 
     * @param createOrUpdatePortForwardingRequest 
     * @return ApiResponse<PortForwarding?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateDevicePortForwardingWithHttpInfo(deviceID: java.util.UUID, portForwardingID: java.util.UUID, createOrUpdatePortForwardingRequest: CreateOrUpdatePortForwardingRequest) : ApiResponse<PortForwarding?> {
        val localVariableConfig = updateDevicePortForwardingRequestConfig(deviceID = deviceID, portForwardingID = portForwardingID, createOrUpdatePortForwardingRequest = createOrUpdatePortForwardingRequest)

        return request<CreateOrUpdatePortForwardingRequest, PortForwarding>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateDevicePortForwarding
     *
     * @param deviceID 
     * @param portForwardingID 
     * @param createOrUpdatePortForwardingRequest 
     * @return RequestConfig
     */
    fun updateDevicePortForwardingRequestConfig(deviceID: java.util.UUID, portForwardingID: java.util.UUID, createOrUpdatePortForwardingRequest: CreateOrUpdatePortForwardingRequest) : RequestConfig<CreateOrUpdatePortForwardingRequest> {
        val localVariableBody = createOrUpdatePortForwardingRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/devices/{deviceID}/port-forwarding/{portForwardingID}/".replace("{"+"deviceID"+"}", encodeURIComponent(deviceID.toString())).replace("{"+"portForwardingID"+"}", encodeURIComponent(portForwardingID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
